// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"task-svc/ent/bed"
	"task-svc/ent/patient"
	"task-svc/ent/predicate"
	"task-svc/ent/room"
	"task-svc/ent/subtask"
	"task-svc/ent/task"
	"task-svc/ent/tasktemplate"
	"task-svc/ent/tasktemplatesubtask"
	"task-svc/ent/ward"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBed                 = "Bed"
	TypePatient             = "Patient"
	TypeRoom                = "Room"
	TypeSubTask             = "SubTask"
	TypeTask                = "Task"
	TypeTaskTemplate        = "TaskTemplate"
	TypeTaskTemplateSubTask = "TaskTemplateSubTask"
	TypeWard                = "Ward"
)

// BedMutation represents an operation that mutates the Bed nodes in the graph.
type BedMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	name            *string
	organization_id *uuid.UUID
	clearedFields   map[string]struct{}
	room            *uuid.UUID
	clearedroom     bool
	patient         *uuid.UUID
	clearedpatient  bool
	done            bool
	oldValue        func(context.Context) (*Bed, error)
	predicates      []predicate.Bed
}

var _ ent.Mutation = (*BedMutation)(nil)

// bedOption allows management of the mutation configuration using functional options.
type bedOption func(*BedMutation)

// newBedMutation creates new mutation for the Bed entity.
func newBedMutation(c config, op Op, opts ...bedOption) *BedMutation {
	m := &BedMutation{
		config:        c,
		op:            op,
		typ:           TypeBed,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBedID sets the ID field of the mutation.
func withBedID(id uuid.UUID) bedOption {
	return func(m *BedMutation) {
		var (
			err   error
			once  sync.Once
			value *Bed
		)
		m.oldValue = func(ctx context.Context) (*Bed, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Bed.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBed sets the old Bed of the mutation.
func withBed(node *Bed) bedOption {
	return func(m *BedMutation) {
		m.oldValue = func(context.Context) (*Bed, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BedMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BedMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Bed entities.
func (m *BedMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BedMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BedMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Bed.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *BedMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BedMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Bed entity.
// If the Bed object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BedMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BedMutation) ResetName() {
	m.name = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *BedMutation) SetOrganizationID(u uuid.UUID) {
	m.organization_id = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *BedMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the Bed entity.
// If the Bed object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BedMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *BedMutation) ResetOrganizationID() {
	m.organization_id = nil
}

// SetRoomID sets the "room" edge to the Room entity by id.
func (m *BedMutation) SetRoomID(id uuid.UUID) {
	m.room = &id
}

// ClearRoom clears the "room" edge to the Room entity.
func (m *BedMutation) ClearRoom() {
	m.clearedroom = true
}

// RoomCleared reports if the "room" edge to the Room entity was cleared.
func (m *BedMutation) RoomCleared() bool {
	return m.clearedroom
}

// RoomID returns the "room" edge ID in the mutation.
func (m *BedMutation) RoomID() (id uuid.UUID, exists bool) {
	if m.room != nil {
		return *m.room, true
	}
	return
}

// RoomIDs returns the "room" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoomID instead. It exists only for internal usage by the builders.
func (m *BedMutation) RoomIDs() (ids []uuid.UUID) {
	if id := m.room; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoom resets all changes to the "room" edge.
func (m *BedMutation) ResetRoom() {
	m.room = nil
	m.clearedroom = false
}

// SetPatientID sets the "patient" edge to the Patient entity by id.
func (m *BedMutation) SetPatientID(id uuid.UUID) {
	m.patient = &id
}

// ClearPatient clears the "patient" edge to the Patient entity.
func (m *BedMutation) ClearPatient() {
	m.clearedpatient = true
}

// PatientCleared reports if the "patient" edge to the Patient entity was cleared.
func (m *BedMutation) PatientCleared() bool {
	return m.clearedpatient
}

// PatientID returns the "patient" edge ID in the mutation.
func (m *BedMutation) PatientID() (id uuid.UUID, exists bool) {
	if m.patient != nil {
		return *m.patient, true
	}
	return
}

// PatientIDs returns the "patient" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PatientID instead. It exists only for internal usage by the builders.
func (m *BedMutation) PatientIDs() (ids []uuid.UUID) {
	if id := m.patient; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPatient resets all changes to the "patient" edge.
func (m *BedMutation) ResetPatient() {
	m.patient = nil
	m.clearedpatient = false
}

// Where appends a list predicates to the BedMutation builder.
func (m *BedMutation) Where(ps ...predicate.Bed) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BedMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BedMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Bed, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BedMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BedMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Bed).
func (m *BedMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BedMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, bed.FieldName)
	}
	if m.organization_id != nil {
		fields = append(fields, bed.FieldOrganizationID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BedMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bed.FieldName:
		return m.Name()
	case bed.FieldOrganizationID:
		return m.OrganizationID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BedMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bed.FieldName:
		return m.OldName(ctx)
	case bed.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	}
	return nil, fmt.Errorf("unknown Bed field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BedMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bed.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case bed.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	}
	return fmt.Errorf("unknown Bed field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BedMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BedMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BedMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Bed numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BedMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BedMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BedMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Bed nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BedMutation) ResetField(name string) error {
	switch name {
	case bed.FieldName:
		m.ResetName()
		return nil
	case bed.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	}
	return fmt.Errorf("unknown Bed field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BedMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.room != nil {
		edges = append(edges, bed.EdgeRoom)
	}
	if m.patient != nil {
		edges = append(edges, bed.EdgePatient)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BedMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bed.EdgeRoom:
		if id := m.room; id != nil {
			return []ent.Value{*id}
		}
	case bed.EdgePatient:
		if id := m.patient; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BedMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BedMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BedMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedroom {
		edges = append(edges, bed.EdgeRoom)
	}
	if m.clearedpatient {
		edges = append(edges, bed.EdgePatient)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BedMutation) EdgeCleared(name string) bool {
	switch name {
	case bed.EdgeRoom:
		return m.clearedroom
	case bed.EdgePatient:
		return m.clearedpatient
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BedMutation) ClearEdge(name string) error {
	switch name {
	case bed.EdgeRoom:
		m.ClearRoom()
		return nil
	case bed.EdgePatient:
		m.ClearPatient()
		return nil
	}
	return fmt.Errorf("unknown Bed unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BedMutation) ResetEdge(name string) error {
	switch name {
	case bed.EdgeRoom:
		m.ResetRoom()
		return nil
	case bed.EdgePatient:
		m.ResetPatient()
		return nil
	}
	return fmt.Errorf("unknown Bed edge %s", name)
}

// PatientMutation represents an operation that mutates the Patient nodes in the graph.
type PatientMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	human_readable_identifier *string
	notes                     *string
	is_discharged             *int
	addis_discharged          *int
	created_at                *time.Time
	updated_at                *time.Time
	organization_id           *uuid.UUID
	clearedFields             map[string]struct{}
	bed                       *uuid.UUID
	clearedbed                bool
	tasks                     map[uuid.UUID]struct{}
	removedtasks              map[uuid.UUID]struct{}
	clearedtasks              bool
	done                      bool
	oldValue                  func(context.Context) (*Patient, error)
	predicates                []predicate.Patient
}

var _ ent.Mutation = (*PatientMutation)(nil)

// patientOption allows management of the mutation configuration using functional options.
type patientOption func(*PatientMutation)

// newPatientMutation creates new mutation for the Patient entity.
func newPatientMutation(c config, op Op, opts ...patientOption) *PatientMutation {
	m := &PatientMutation{
		config:        c,
		op:            op,
		typ:           TypePatient,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPatientID sets the ID field of the mutation.
func withPatientID(id uuid.UUID) patientOption {
	return func(m *PatientMutation) {
		var (
			err   error
			once  sync.Once
			value *Patient
		)
		m.oldValue = func(ctx context.Context) (*Patient, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Patient.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPatient sets the old Patient of the mutation.
func withPatient(node *Patient) patientOption {
	return func(m *PatientMutation) {
		m.oldValue = func(context.Context) (*Patient, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PatientMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PatientMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Patient entities.
func (m *PatientMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PatientMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PatientMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Patient.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHumanReadableIdentifier sets the "human_readable_identifier" field.
func (m *PatientMutation) SetHumanReadableIdentifier(s string) {
	m.human_readable_identifier = &s
}

// HumanReadableIdentifier returns the value of the "human_readable_identifier" field in the mutation.
func (m *PatientMutation) HumanReadableIdentifier() (r string, exists bool) {
	v := m.human_readable_identifier
	if v == nil {
		return
	}
	return *v, true
}

// OldHumanReadableIdentifier returns the old "human_readable_identifier" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldHumanReadableIdentifier(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHumanReadableIdentifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHumanReadableIdentifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHumanReadableIdentifier: %w", err)
	}
	return oldValue.HumanReadableIdentifier, nil
}

// ResetHumanReadableIdentifier resets all changes to the "human_readable_identifier" field.
func (m *PatientMutation) ResetHumanReadableIdentifier() {
	m.human_readable_identifier = nil
}

// SetNotes sets the "notes" field.
func (m *PatientMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *PatientMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ResetNotes resets all changes to the "notes" field.
func (m *PatientMutation) ResetNotes() {
	m.notes = nil
}

// SetIsDischarged sets the "is_discharged" field.
func (m *PatientMutation) SetIsDischarged(i int) {
	m.is_discharged = &i
	m.addis_discharged = nil
}

// IsDischarged returns the value of the "is_discharged" field in the mutation.
func (m *PatientMutation) IsDischarged() (r int, exists bool) {
	v := m.is_discharged
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDischarged returns the old "is_discharged" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldIsDischarged(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDischarged is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDischarged requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDischarged: %w", err)
	}
	return oldValue.IsDischarged, nil
}

// AddIsDischarged adds i to the "is_discharged" field.
func (m *PatientMutation) AddIsDischarged(i int) {
	if m.addis_discharged != nil {
		*m.addis_discharged += i
	} else {
		m.addis_discharged = &i
	}
}

// AddedIsDischarged returns the value that was added to the "is_discharged" field in this mutation.
func (m *PatientMutation) AddedIsDischarged() (r int, exists bool) {
	v := m.addis_discharged
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDischarged resets all changes to the "is_discharged" field.
func (m *PatientMutation) ResetIsDischarged() {
	m.is_discharged = nil
	m.addis_discharged = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PatientMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PatientMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PatientMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PatientMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PatientMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PatientMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *PatientMutation) SetOrganizationID(u uuid.UUID) {
	m.organization_id = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *PatientMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *PatientMutation) ResetOrganizationID() {
	m.organization_id = nil
}

// SetBedID sets the "bed" edge to the Bed entity by id.
func (m *PatientMutation) SetBedID(id uuid.UUID) {
	m.bed = &id
}

// ClearBed clears the "bed" edge to the Bed entity.
func (m *PatientMutation) ClearBed() {
	m.clearedbed = true
}

// BedCleared reports if the "bed" edge to the Bed entity was cleared.
func (m *PatientMutation) BedCleared() bool {
	return m.clearedbed
}

// BedID returns the "bed" edge ID in the mutation.
func (m *PatientMutation) BedID() (id uuid.UUID, exists bool) {
	if m.bed != nil {
		return *m.bed, true
	}
	return
}

// BedIDs returns the "bed" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BedID instead. It exists only for internal usage by the builders.
func (m *PatientMutation) BedIDs() (ids []uuid.UUID) {
	if id := m.bed; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBed resets all changes to the "bed" edge.
func (m *PatientMutation) ResetBed() {
	m.bed = nil
	m.clearedbed = false
}

// AddTaskIDs adds the "tasks" edge to the Task entity by ids.
func (m *PatientMutation) AddTaskIDs(ids ...uuid.UUID) {
	if m.tasks == nil {
		m.tasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.tasks[ids[i]] = struct{}{}
	}
}

// ClearTasks clears the "tasks" edge to the Task entity.
func (m *PatientMutation) ClearTasks() {
	m.clearedtasks = true
}

// TasksCleared reports if the "tasks" edge to the Task entity was cleared.
func (m *PatientMutation) TasksCleared() bool {
	return m.clearedtasks
}

// RemoveTaskIDs removes the "tasks" edge to the Task entity by IDs.
func (m *PatientMutation) RemoveTaskIDs(ids ...uuid.UUID) {
	if m.removedtasks == nil {
		m.removedtasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.tasks, ids[i])
		m.removedtasks[ids[i]] = struct{}{}
	}
}

// RemovedTasks returns the removed IDs of the "tasks" edge to the Task entity.
func (m *PatientMutation) RemovedTasksIDs() (ids []uuid.UUID) {
	for id := range m.removedtasks {
		ids = append(ids, id)
	}
	return
}

// TasksIDs returns the "tasks" edge IDs in the mutation.
func (m *PatientMutation) TasksIDs() (ids []uuid.UUID) {
	for id := range m.tasks {
		ids = append(ids, id)
	}
	return
}

// ResetTasks resets all changes to the "tasks" edge.
func (m *PatientMutation) ResetTasks() {
	m.tasks = nil
	m.clearedtasks = false
	m.removedtasks = nil
}

// Where appends a list predicates to the PatientMutation builder.
func (m *PatientMutation) Where(ps ...predicate.Patient) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PatientMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PatientMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Patient, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PatientMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PatientMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Patient).
func (m *PatientMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PatientMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.human_readable_identifier != nil {
		fields = append(fields, patient.FieldHumanReadableIdentifier)
	}
	if m.notes != nil {
		fields = append(fields, patient.FieldNotes)
	}
	if m.is_discharged != nil {
		fields = append(fields, patient.FieldIsDischarged)
	}
	if m.created_at != nil {
		fields = append(fields, patient.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, patient.FieldUpdatedAt)
	}
	if m.organization_id != nil {
		fields = append(fields, patient.FieldOrganizationID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PatientMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case patient.FieldHumanReadableIdentifier:
		return m.HumanReadableIdentifier()
	case patient.FieldNotes:
		return m.Notes()
	case patient.FieldIsDischarged:
		return m.IsDischarged()
	case patient.FieldCreatedAt:
		return m.CreatedAt()
	case patient.FieldUpdatedAt:
		return m.UpdatedAt()
	case patient.FieldOrganizationID:
		return m.OrganizationID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PatientMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case patient.FieldHumanReadableIdentifier:
		return m.OldHumanReadableIdentifier(ctx)
	case patient.FieldNotes:
		return m.OldNotes(ctx)
	case patient.FieldIsDischarged:
		return m.OldIsDischarged(ctx)
	case patient.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case patient.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case patient.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	}
	return nil, fmt.Errorf("unknown Patient field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PatientMutation) SetField(name string, value ent.Value) error {
	switch name {
	case patient.FieldHumanReadableIdentifier:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHumanReadableIdentifier(v)
		return nil
	case patient.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case patient.FieldIsDischarged:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDischarged(v)
		return nil
	case patient.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case patient.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case patient.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	}
	return fmt.Errorf("unknown Patient field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PatientMutation) AddedFields() []string {
	var fields []string
	if m.addis_discharged != nil {
		fields = append(fields, patient.FieldIsDischarged)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PatientMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case patient.FieldIsDischarged:
		return m.AddedIsDischarged()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PatientMutation) AddField(name string, value ent.Value) error {
	switch name {
	case patient.FieldIsDischarged:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDischarged(v)
		return nil
	}
	return fmt.Errorf("unknown Patient numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PatientMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PatientMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PatientMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Patient nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PatientMutation) ResetField(name string) error {
	switch name {
	case patient.FieldHumanReadableIdentifier:
		m.ResetHumanReadableIdentifier()
		return nil
	case patient.FieldNotes:
		m.ResetNotes()
		return nil
	case patient.FieldIsDischarged:
		m.ResetIsDischarged()
		return nil
	case patient.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case patient.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case patient.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	}
	return fmt.Errorf("unknown Patient field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PatientMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.bed != nil {
		edges = append(edges, patient.EdgeBed)
	}
	if m.tasks != nil {
		edges = append(edges, patient.EdgeTasks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PatientMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case patient.EdgeBed:
		if id := m.bed; id != nil {
			return []ent.Value{*id}
		}
	case patient.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.tasks))
		for id := range m.tasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PatientMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtasks != nil {
		edges = append(edges, patient.EdgeTasks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PatientMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case patient.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.removedtasks))
		for id := range m.removedtasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PatientMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbed {
		edges = append(edges, patient.EdgeBed)
	}
	if m.clearedtasks {
		edges = append(edges, patient.EdgeTasks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PatientMutation) EdgeCleared(name string) bool {
	switch name {
	case patient.EdgeBed:
		return m.clearedbed
	case patient.EdgeTasks:
		return m.clearedtasks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PatientMutation) ClearEdge(name string) error {
	switch name {
	case patient.EdgeBed:
		m.ClearBed()
		return nil
	}
	return fmt.Errorf("unknown Patient unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PatientMutation) ResetEdge(name string) error {
	switch name {
	case patient.EdgeBed:
		m.ResetBed()
		return nil
	case patient.EdgeTasks:
		m.ResetTasks()
		return nil
	}
	return fmt.Errorf("unknown Patient edge %s", name)
}

// RoomMutation represents an operation that mutates the Room nodes in the graph.
type RoomMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	name            *string
	organization_id *uuid.UUID
	clearedFields   map[string]struct{}
	beds            map[uuid.UUID]struct{}
	removedbeds     map[uuid.UUID]struct{}
	clearedbeds     bool
	ward            *uuid.UUID
	clearedward     bool
	done            bool
	oldValue        func(context.Context) (*Room, error)
	predicates      []predicate.Room
}

var _ ent.Mutation = (*RoomMutation)(nil)

// roomOption allows management of the mutation configuration using functional options.
type roomOption func(*RoomMutation)

// newRoomMutation creates new mutation for the Room entity.
func newRoomMutation(c config, op Op, opts ...roomOption) *RoomMutation {
	m := &RoomMutation{
		config:        c,
		op:            op,
		typ:           TypeRoom,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoomID sets the ID field of the mutation.
func withRoomID(id uuid.UUID) roomOption {
	return func(m *RoomMutation) {
		var (
			err   error
			once  sync.Once
			value *Room
		)
		m.oldValue = func(ctx context.Context) (*Room, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Room.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRoom sets the old Room of the mutation.
func withRoom(node *Room) roomOption {
	return func(m *RoomMutation) {
		m.oldValue = func(context.Context) (*Room, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoomMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoomMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Room entities.
func (m *RoomMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoomMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoomMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Room.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *RoomMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RoomMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Room entity.
// If the Room object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RoomMutation) ResetName() {
	m.name = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *RoomMutation) SetOrganizationID(u uuid.UUID) {
	m.organization_id = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *RoomMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the Room entity.
// If the Room object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *RoomMutation) ResetOrganizationID() {
	m.organization_id = nil
}

// AddBedIDs adds the "beds" edge to the Bed entity by ids.
func (m *RoomMutation) AddBedIDs(ids ...uuid.UUID) {
	if m.beds == nil {
		m.beds = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.beds[ids[i]] = struct{}{}
	}
}

// ClearBeds clears the "beds" edge to the Bed entity.
func (m *RoomMutation) ClearBeds() {
	m.clearedbeds = true
}

// BedsCleared reports if the "beds" edge to the Bed entity was cleared.
func (m *RoomMutation) BedsCleared() bool {
	return m.clearedbeds
}

// RemoveBedIDs removes the "beds" edge to the Bed entity by IDs.
func (m *RoomMutation) RemoveBedIDs(ids ...uuid.UUID) {
	if m.removedbeds == nil {
		m.removedbeds = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.beds, ids[i])
		m.removedbeds[ids[i]] = struct{}{}
	}
}

// RemovedBeds returns the removed IDs of the "beds" edge to the Bed entity.
func (m *RoomMutation) RemovedBedsIDs() (ids []uuid.UUID) {
	for id := range m.removedbeds {
		ids = append(ids, id)
	}
	return
}

// BedsIDs returns the "beds" edge IDs in the mutation.
func (m *RoomMutation) BedsIDs() (ids []uuid.UUID) {
	for id := range m.beds {
		ids = append(ids, id)
	}
	return
}

// ResetBeds resets all changes to the "beds" edge.
func (m *RoomMutation) ResetBeds() {
	m.beds = nil
	m.clearedbeds = false
	m.removedbeds = nil
}

// SetWardID sets the "ward" edge to the Ward entity by id.
func (m *RoomMutation) SetWardID(id uuid.UUID) {
	m.ward = &id
}

// ClearWard clears the "ward" edge to the Ward entity.
func (m *RoomMutation) ClearWard() {
	m.clearedward = true
}

// WardCleared reports if the "ward" edge to the Ward entity was cleared.
func (m *RoomMutation) WardCleared() bool {
	return m.clearedward
}

// WardID returns the "ward" edge ID in the mutation.
func (m *RoomMutation) WardID() (id uuid.UUID, exists bool) {
	if m.ward != nil {
		return *m.ward, true
	}
	return
}

// WardIDs returns the "ward" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WardID instead. It exists only for internal usage by the builders.
func (m *RoomMutation) WardIDs() (ids []uuid.UUID) {
	if id := m.ward; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWard resets all changes to the "ward" edge.
func (m *RoomMutation) ResetWard() {
	m.ward = nil
	m.clearedward = false
}

// Where appends a list predicates to the RoomMutation builder.
func (m *RoomMutation) Where(ps ...predicate.Room) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoomMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoomMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Room, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoomMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoomMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Room).
func (m *RoomMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoomMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, room.FieldName)
	}
	if m.organization_id != nil {
		fields = append(fields, room.FieldOrganizationID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoomMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case room.FieldName:
		return m.Name()
	case room.FieldOrganizationID:
		return m.OrganizationID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoomMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case room.FieldName:
		return m.OldName(ctx)
	case room.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	}
	return nil, fmt.Errorf("unknown Room field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoomMutation) SetField(name string, value ent.Value) error {
	switch name {
	case room.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case room.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	}
	return fmt.Errorf("unknown Room field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoomMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoomMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoomMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Room numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoomMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoomMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoomMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Room nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoomMutation) ResetField(name string) error {
	switch name {
	case room.FieldName:
		m.ResetName()
		return nil
	case room.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	}
	return fmt.Errorf("unknown Room field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoomMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.beds != nil {
		edges = append(edges, room.EdgeBeds)
	}
	if m.ward != nil {
		edges = append(edges, room.EdgeWard)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoomMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case room.EdgeBeds:
		ids := make([]ent.Value, 0, len(m.beds))
		for id := range m.beds {
			ids = append(ids, id)
		}
		return ids
	case room.EdgeWard:
		if id := m.ward; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoomMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedbeds != nil {
		edges = append(edges, room.EdgeBeds)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoomMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case room.EdgeBeds:
		ids := make([]ent.Value, 0, len(m.removedbeds))
		for id := range m.removedbeds {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoomMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbeds {
		edges = append(edges, room.EdgeBeds)
	}
	if m.clearedward {
		edges = append(edges, room.EdgeWard)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoomMutation) EdgeCleared(name string) bool {
	switch name {
	case room.EdgeBeds:
		return m.clearedbeds
	case room.EdgeWard:
		return m.clearedward
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoomMutation) ClearEdge(name string) error {
	switch name {
	case room.EdgeWard:
		m.ClearWard()
		return nil
	}
	return fmt.Errorf("unknown Room unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoomMutation) ResetEdge(name string) error {
	switch name {
	case room.EdgeBeds:
		m.ResetBeds()
		return nil
	case room.EdgeWard:
		m.ResetWard()
		return nil
	}
	return fmt.Errorf("unknown Room edge %s", name)
}

// SubTaskMutation represents an operation that mutates the SubTask nodes in the graph.
type SubTaskMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	name          *string
	_done         *bool
	creation_date *time.Time
	created_by    *uuid.UUID
	clearedFields map[string]struct{}
	task          *uuid.UUID
	clearedtask   bool
	done          bool
	oldValue      func(context.Context) (*SubTask, error)
	predicates    []predicate.SubTask
}

var _ ent.Mutation = (*SubTaskMutation)(nil)

// subtaskOption allows management of the mutation configuration using functional options.
type subtaskOption func(*SubTaskMutation)

// newSubTaskMutation creates new mutation for the SubTask entity.
func newSubTaskMutation(c config, op Op, opts ...subtaskOption) *SubTaskMutation {
	m := &SubTaskMutation{
		config:        c,
		op:            op,
		typ:           TypeSubTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubTaskID sets the ID field of the mutation.
func withSubTaskID(id uuid.UUID) subtaskOption {
	return func(m *SubTaskMutation) {
		var (
			err   error
			once  sync.Once
			value *SubTask
		)
		m.oldValue = func(ctx context.Context) (*SubTask, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SubTask.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubTask sets the old SubTask of the mutation.
func withSubTask(node *SubTask) subtaskOption {
	return func(m *SubTaskMutation) {
		m.oldValue = func(context.Context) (*SubTask, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubTaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubTaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SubTask entities.
func (m *SubTaskMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubTaskMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubTaskMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SubTask.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *SubTaskMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SubTaskMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SubTask entity.
// If the SubTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubTaskMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SubTaskMutation) ResetName() {
	m.name = nil
}

// SetDone sets the "done" field.
func (m *SubTaskMutation) SetDone(b bool) {
	m._done = &b
}

// Done returns the value of the "done" field in the mutation.
func (m *SubTaskMutation) Done() (r bool, exists bool) {
	v := m._done
	if v == nil {
		return
	}
	return *v, true
}

// OldDone returns the old "done" field's value of the SubTask entity.
// If the SubTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubTaskMutation) OldDone(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDone: %w", err)
	}
	return oldValue.Done, nil
}

// ResetDone resets all changes to the "done" field.
func (m *SubTaskMutation) ResetDone() {
	m._done = nil
}

// SetCreationDate sets the "creation_date" field.
func (m *SubTaskMutation) SetCreationDate(t time.Time) {
	m.creation_date = &t
}

// CreationDate returns the value of the "creation_date" field in the mutation.
func (m *SubTaskMutation) CreationDate() (r time.Time, exists bool) {
	v := m.creation_date
	if v == nil {
		return
	}
	return *v, true
}

// OldCreationDate returns the old "creation_date" field's value of the SubTask entity.
// If the SubTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubTaskMutation) OldCreationDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreationDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreationDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreationDate: %w", err)
	}
	return oldValue.CreationDate, nil
}

// ResetCreationDate resets all changes to the "creation_date" field.
func (m *SubTaskMutation) ResetCreationDate() {
	m.creation_date = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *SubTaskMutation) SetCreatedBy(u uuid.UUID) {
	m.created_by = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *SubTaskMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the SubTask entity.
// If the SubTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubTaskMutation) OldCreatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *SubTaskMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetTaskID sets the "task" edge to the Task entity by id.
func (m *SubTaskMutation) SetTaskID(id uuid.UUID) {
	m.task = &id
}

// ClearTask clears the "task" edge to the Task entity.
func (m *SubTaskMutation) ClearTask() {
	m.clearedtask = true
}

// TaskCleared reports if the "task" edge to the Task entity was cleared.
func (m *SubTaskMutation) TaskCleared() bool {
	return m.clearedtask
}

// TaskID returns the "task" edge ID in the mutation.
func (m *SubTaskMutation) TaskID() (id uuid.UUID, exists bool) {
	if m.task != nil {
		return *m.task, true
	}
	return
}

// TaskIDs returns the "task" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaskID instead. It exists only for internal usage by the builders.
func (m *SubTaskMutation) TaskIDs() (ids []uuid.UUID) {
	if id := m.task; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTask resets all changes to the "task" edge.
func (m *SubTaskMutation) ResetTask() {
	m.task = nil
	m.clearedtask = false
}

// Where appends a list predicates to the SubTaskMutation builder.
func (m *SubTaskMutation) Where(ps ...predicate.SubTask) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SubTaskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SubTaskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SubTask, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SubTaskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SubTaskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SubTask).
func (m *SubTaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubTaskMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, subtask.FieldName)
	}
	if m._done != nil {
		fields = append(fields, subtask.FieldDone)
	}
	if m.creation_date != nil {
		fields = append(fields, subtask.FieldCreationDate)
	}
	if m.created_by != nil {
		fields = append(fields, subtask.FieldCreatedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubTaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subtask.FieldName:
		return m.Name()
	case subtask.FieldDone:
		return m.Done()
	case subtask.FieldCreationDate:
		return m.CreationDate()
	case subtask.FieldCreatedBy:
		return m.CreatedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubTaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subtask.FieldName:
		return m.OldName(ctx)
	case subtask.FieldDone:
		return m.OldDone(ctx)
	case subtask.FieldCreationDate:
		return m.OldCreationDate(ctx)
	case subtask.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	}
	return nil, fmt.Errorf("unknown SubTask field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubTaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subtask.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case subtask.FieldDone:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDone(v)
		return nil
	case subtask.FieldCreationDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreationDate(v)
		return nil
	case subtask.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown SubTask field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubTaskMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubTaskMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubTaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SubTask numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubTaskMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubTaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubTaskMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SubTask nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubTaskMutation) ResetField(name string) error {
	switch name {
	case subtask.FieldName:
		m.ResetName()
		return nil
	case subtask.FieldDone:
		m.ResetDone()
		return nil
	case subtask.FieldCreationDate:
		m.ResetCreationDate()
		return nil
	case subtask.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	}
	return fmt.Errorf("unknown SubTask field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubTaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.task != nil {
		edges = append(edges, subtask.EdgeTask)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubTaskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subtask.EdgeTask:
		if id := m.task; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubTaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubTaskMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubTaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtask {
		edges = append(edges, subtask.EdgeTask)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubTaskMutation) EdgeCleared(name string) bool {
	switch name {
	case subtask.EdgeTask:
		return m.clearedtask
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubTaskMutation) ClearEdge(name string) error {
	switch name {
	case subtask.EdgeTask:
		m.ClearTask()
		return nil
	}
	return fmt.Errorf("unknown SubTask unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubTaskMutation) ResetEdge(name string) error {
	switch name {
	case subtask.EdgeTask:
		m.ResetTask()
		return nil
	}
	return fmt.Errorf("unknown SubTask edge %s", name)
}

// TaskMutation represents an operation that mutates the Task nodes in the graph.
type TaskMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	name             *string
	description      *string
	public           *bool
	status           *int32
	addstatus        *int32
	due_at           *time.Time
	created_by       *uuid.UUID
	assigned_user_id *uuid.UUID
	organization_id  *uuid.UUID
	clearedFields    map[string]struct{}
	patient          *uuid.UUID
	clearedpatient   bool
	subtasks         map[uuid.UUID]struct{}
	removedsubtasks  map[uuid.UUID]struct{}
	clearedsubtasks  bool
	done             bool
	oldValue         func(context.Context) (*Task, error)
	predicates       []predicate.Task
}

var _ ent.Mutation = (*TaskMutation)(nil)

// taskOption allows management of the mutation configuration using functional options.
type taskOption func(*TaskMutation)

// newTaskMutation creates new mutation for the Task entity.
func newTaskMutation(c config, op Op, opts ...taskOption) *TaskMutation {
	m := &TaskMutation{
		config:        c,
		op:            op,
		typ:           TypeTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskID sets the ID field of the mutation.
func withTaskID(id uuid.UUID) taskOption {
	return func(m *TaskMutation) {
		var (
			err   error
			once  sync.Once
			value *Task
		)
		m.oldValue = func(ctx context.Context) (*Task, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Task.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTask sets the old Task of the mutation.
func withTask(node *Task) taskOption {
	return func(m *TaskMutation) {
		m.oldValue = func(context.Context) (*Task, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Task entities.
func (m *TaskMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Task.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TaskMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TaskMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TaskMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *TaskMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TaskMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *TaskMutation) ResetDescription() {
	m.description = nil
}

// SetPublic sets the "public" field.
func (m *TaskMutation) SetPublic(b bool) {
	m.public = &b
}

// Public returns the value of the "public" field in the mutation.
func (m *TaskMutation) Public() (r bool, exists bool) {
	v := m.public
	if v == nil {
		return
	}
	return *v, true
}

// OldPublic returns the old "public" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublic: %w", err)
	}
	return oldValue.Public, nil
}

// ResetPublic resets all changes to the "public" field.
func (m *TaskMutation) ResetPublic() {
	m.public = nil
}

// SetStatus sets the "status" field.
func (m *TaskMutation) SetStatus(i int32) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *TaskMutation) Status() (r int32, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldStatus(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *TaskMutation) AddStatus(i int32) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *TaskMutation) AddedStatus() (r int32, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *TaskMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetDueAt sets the "due_at" field.
func (m *TaskMutation) SetDueAt(t time.Time) {
	m.due_at = &t
}

// DueAt returns the value of the "due_at" field in the mutation.
func (m *TaskMutation) DueAt() (r time.Time, exists bool) {
	v := m.due_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDueAt returns the old "due_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldDueAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDueAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDueAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDueAt: %w", err)
	}
	return oldValue.DueAt, nil
}

// ResetDueAt resets all changes to the "due_at" field.
func (m *TaskMutation) ResetDueAt() {
	m.due_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *TaskMutation) SetCreatedBy(u uuid.UUID) {
	m.created_by = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TaskMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCreatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TaskMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetAssignedUserID sets the "assigned_user_id" field.
func (m *TaskMutation) SetAssignedUserID(u uuid.UUID) {
	m.assigned_user_id = &u
}

// AssignedUserID returns the value of the "assigned_user_id" field in the mutation.
func (m *TaskMutation) AssignedUserID() (r uuid.UUID, exists bool) {
	v := m.assigned_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignedUserID returns the old "assigned_user_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldAssignedUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignedUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignedUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignedUserID: %w", err)
	}
	return oldValue.AssignedUserID, nil
}

// ResetAssignedUserID resets all changes to the "assigned_user_id" field.
func (m *TaskMutation) ResetAssignedUserID() {
	m.assigned_user_id = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *TaskMutation) SetOrganizationID(u uuid.UUID) {
	m.organization_id = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *TaskMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *TaskMutation) ResetOrganizationID() {
	m.organization_id = nil
}

// SetPatientID sets the "patient" edge to the Patient entity by id.
func (m *TaskMutation) SetPatientID(id uuid.UUID) {
	m.patient = &id
}

// ClearPatient clears the "patient" edge to the Patient entity.
func (m *TaskMutation) ClearPatient() {
	m.clearedpatient = true
}

// PatientCleared reports if the "patient" edge to the Patient entity was cleared.
func (m *TaskMutation) PatientCleared() bool {
	return m.clearedpatient
}

// PatientID returns the "patient" edge ID in the mutation.
func (m *TaskMutation) PatientID() (id uuid.UUID, exists bool) {
	if m.patient != nil {
		return *m.patient, true
	}
	return
}

// PatientIDs returns the "patient" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PatientID instead. It exists only for internal usage by the builders.
func (m *TaskMutation) PatientIDs() (ids []uuid.UUID) {
	if id := m.patient; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPatient resets all changes to the "patient" edge.
func (m *TaskMutation) ResetPatient() {
	m.patient = nil
	m.clearedpatient = false
}

// AddSubtaskIDs adds the "subtasks" edge to the SubTask entity by ids.
func (m *TaskMutation) AddSubtaskIDs(ids ...uuid.UUID) {
	if m.subtasks == nil {
		m.subtasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.subtasks[ids[i]] = struct{}{}
	}
}

// ClearSubtasks clears the "subtasks" edge to the SubTask entity.
func (m *TaskMutation) ClearSubtasks() {
	m.clearedsubtasks = true
}

// SubtasksCleared reports if the "subtasks" edge to the SubTask entity was cleared.
func (m *TaskMutation) SubtasksCleared() bool {
	return m.clearedsubtasks
}

// RemoveSubtaskIDs removes the "subtasks" edge to the SubTask entity by IDs.
func (m *TaskMutation) RemoveSubtaskIDs(ids ...uuid.UUID) {
	if m.removedsubtasks == nil {
		m.removedsubtasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.subtasks, ids[i])
		m.removedsubtasks[ids[i]] = struct{}{}
	}
}

// RemovedSubtasks returns the removed IDs of the "subtasks" edge to the SubTask entity.
func (m *TaskMutation) RemovedSubtasksIDs() (ids []uuid.UUID) {
	for id := range m.removedsubtasks {
		ids = append(ids, id)
	}
	return
}

// SubtasksIDs returns the "subtasks" edge IDs in the mutation.
func (m *TaskMutation) SubtasksIDs() (ids []uuid.UUID) {
	for id := range m.subtasks {
		ids = append(ids, id)
	}
	return
}

// ResetSubtasks resets all changes to the "subtasks" edge.
func (m *TaskMutation) ResetSubtasks() {
	m.subtasks = nil
	m.clearedsubtasks = false
	m.removedsubtasks = nil
}

// Where appends a list predicates to the TaskMutation builder.
func (m *TaskMutation) Where(ps ...predicate.Task) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TaskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TaskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Task, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TaskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TaskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Task).
func (m *TaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.name != nil {
		fields = append(fields, task.FieldName)
	}
	if m.description != nil {
		fields = append(fields, task.FieldDescription)
	}
	if m.public != nil {
		fields = append(fields, task.FieldPublic)
	}
	if m.status != nil {
		fields = append(fields, task.FieldStatus)
	}
	if m.due_at != nil {
		fields = append(fields, task.FieldDueAt)
	}
	if m.created_by != nil {
		fields = append(fields, task.FieldCreatedBy)
	}
	if m.assigned_user_id != nil {
		fields = append(fields, task.FieldAssignedUserID)
	}
	if m.organization_id != nil {
		fields = append(fields, task.FieldOrganizationID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case task.FieldName:
		return m.Name()
	case task.FieldDescription:
		return m.Description()
	case task.FieldPublic:
		return m.Public()
	case task.FieldStatus:
		return m.Status()
	case task.FieldDueAt:
		return m.DueAt()
	case task.FieldCreatedBy:
		return m.CreatedBy()
	case task.FieldAssignedUserID:
		return m.AssignedUserID()
	case task.FieldOrganizationID:
		return m.OrganizationID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case task.FieldName:
		return m.OldName(ctx)
	case task.FieldDescription:
		return m.OldDescription(ctx)
	case task.FieldPublic:
		return m.OldPublic(ctx)
	case task.FieldStatus:
		return m.OldStatus(ctx)
	case task.FieldDueAt:
		return m.OldDueAt(ctx)
	case task.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case task.FieldAssignedUserID:
		return m.OldAssignedUserID(ctx)
	case task.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	}
	return nil, fmt.Errorf("unknown Task field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case task.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case task.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case task.FieldPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublic(v)
		return nil
	case task.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case task.FieldDueAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDueAt(v)
		return nil
	case task.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case task.FieldAssignedUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignedUserID(v)
		return nil
	case task.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, task.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case task.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	case task.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Task numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Task nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskMutation) ResetField(name string) error {
	switch name {
	case task.FieldName:
		m.ResetName()
		return nil
	case task.FieldDescription:
		m.ResetDescription()
		return nil
	case task.FieldPublic:
		m.ResetPublic()
		return nil
	case task.FieldStatus:
		m.ResetStatus()
		return nil
	case task.FieldDueAt:
		m.ResetDueAt()
		return nil
	case task.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case task.FieldAssignedUserID:
		m.ResetAssignedUserID()
		return nil
	case task.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.patient != nil {
		edges = append(edges, task.EdgePatient)
	}
	if m.subtasks != nil {
		edges = append(edges, task.EdgeSubtasks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case task.EdgePatient:
		if id := m.patient; id != nil {
			return []ent.Value{*id}
		}
	case task.EdgeSubtasks:
		ids := make([]ent.Value, 0, len(m.subtasks))
		for id := range m.subtasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedsubtasks != nil {
		edges = append(edges, task.EdgeSubtasks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case task.EdgeSubtasks:
		ids := make([]ent.Value, 0, len(m.removedsubtasks))
		for id := range m.removedsubtasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedpatient {
		edges = append(edges, task.EdgePatient)
	}
	if m.clearedsubtasks {
		edges = append(edges, task.EdgeSubtasks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskMutation) EdgeCleared(name string) bool {
	switch name {
	case task.EdgePatient:
		return m.clearedpatient
	case task.EdgeSubtasks:
		return m.clearedsubtasks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskMutation) ClearEdge(name string) error {
	switch name {
	case task.EdgePatient:
		m.ClearPatient()
		return nil
	}
	return fmt.Errorf("unknown Task unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskMutation) ResetEdge(name string) error {
	switch name {
	case task.EdgePatient:
		m.ResetPatient()
		return nil
	case task.EdgeSubtasks:
		m.ResetSubtasks()
		return nil
	}
	return fmt.Errorf("unknown Task edge %s", name)
}

// TaskTemplateMutation represents an operation that mutates the TaskTemplate nodes in the graph.
type TaskTemplateMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	name            *string
	description     *string
	created_by      *uuid.UUID
	organization_id *uuid.UUID
	clearedFields   map[string]struct{}
	ward            *uuid.UUID
	clearedward     bool
	subtasks        map[uuid.UUID]struct{}
	removedsubtasks map[uuid.UUID]struct{}
	clearedsubtasks bool
	done            bool
	oldValue        func(context.Context) (*TaskTemplate, error)
	predicates      []predicate.TaskTemplate
}

var _ ent.Mutation = (*TaskTemplateMutation)(nil)

// tasktemplateOption allows management of the mutation configuration using functional options.
type tasktemplateOption func(*TaskTemplateMutation)

// newTaskTemplateMutation creates new mutation for the TaskTemplate entity.
func newTaskTemplateMutation(c config, op Op, opts ...tasktemplateOption) *TaskTemplateMutation {
	m := &TaskTemplateMutation{
		config:        c,
		op:            op,
		typ:           TypeTaskTemplate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskTemplateID sets the ID field of the mutation.
func withTaskTemplateID(id uuid.UUID) tasktemplateOption {
	return func(m *TaskTemplateMutation) {
		var (
			err   error
			once  sync.Once
			value *TaskTemplate
		)
		m.oldValue = func(ctx context.Context) (*TaskTemplate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TaskTemplate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTaskTemplate sets the old TaskTemplate of the mutation.
func withTaskTemplate(node *TaskTemplate) tasktemplateOption {
	return func(m *TaskTemplateMutation) {
		m.oldValue = func(context.Context) (*TaskTemplate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskTemplateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskTemplateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TaskTemplate entities.
func (m *TaskTemplateMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskTemplateMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskTemplateMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TaskTemplate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TaskTemplateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TaskTemplateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TaskTemplate entity.
// If the TaskTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskTemplateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TaskTemplateMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *TaskTemplateMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TaskTemplateMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the TaskTemplate entity.
// If the TaskTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskTemplateMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *TaskTemplateMutation) ResetDescription() {
	m.description = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *TaskTemplateMutation) SetCreatedBy(u uuid.UUID) {
	m.created_by = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TaskTemplateMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the TaskTemplate entity.
// If the TaskTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskTemplateMutation) OldCreatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TaskTemplateMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *TaskTemplateMutation) SetOrganizationID(u uuid.UUID) {
	m.organization_id = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *TaskTemplateMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the TaskTemplate entity.
// If the TaskTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskTemplateMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *TaskTemplateMutation) ResetOrganizationID() {
	m.organization_id = nil
}

// SetWardID sets the "ward" edge to the Ward entity by id.
func (m *TaskTemplateMutation) SetWardID(id uuid.UUID) {
	m.ward = &id
}

// ClearWard clears the "ward" edge to the Ward entity.
func (m *TaskTemplateMutation) ClearWard() {
	m.clearedward = true
}

// WardCleared reports if the "ward" edge to the Ward entity was cleared.
func (m *TaskTemplateMutation) WardCleared() bool {
	return m.clearedward
}

// WardID returns the "ward" edge ID in the mutation.
func (m *TaskTemplateMutation) WardID() (id uuid.UUID, exists bool) {
	if m.ward != nil {
		return *m.ward, true
	}
	return
}

// WardIDs returns the "ward" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WardID instead. It exists only for internal usage by the builders.
func (m *TaskTemplateMutation) WardIDs() (ids []uuid.UUID) {
	if id := m.ward; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWard resets all changes to the "ward" edge.
func (m *TaskTemplateMutation) ResetWard() {
	m.ward = nil
	m.clearedward = false
}

// AddSubtaskIDs adds the "subtasks" edge to the TaskTemplateSubTask entity by ids.
func (m *TaskTemplateMutation) AddSubtaskIDs(ids ...uuid.UUID) {
	if m.subtasks == nil {
		m.subtasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.subtasks[ids[i]] = struct{}{}
	}
}

// ClearSubtasks clears the "subtasks" edge to the TaskTemplateSubTask entity.
func (m *TaskTemplateMutation) ClearSubtasks() {
	m.clearedsubtasks = true
}

// SubtasksCleared reports if the "subtasks" edge to the TaskTemplateSubTask entity was cleared.
func (m *TaskTemplateMutation) SubtasksCleared() bool {
	return m.clearedsubtasks
}

// RemoveSubtaskIDs removes the "subtasks" edge to the TaskTemplateSubTask entity by IDs.
func (m *TaskTemplateMutation) RemoveSubtaskIDs(ids ...uuid.UUID) {
	if m.removedsubtasks == nil {
		m.removedsubtasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.subtasks, ids[i])
		m.removedsubtasks[ids[i]] = struct{}{}
	}
}

// RemovedSubtasks returns the removed IDs of the "subtasks" edge to the TaskTemplateSubTask entity.
func (m *TaskTemplateMutation) RemovedSubtasksIDs() (ids []uuid.UUID) {
	for id := range m.removedsubtasks {
		ids = append(ids, id)
	}
	return
}

// SubtasksIDs returns the "subtasks" edge IDs in the mutation.
func (m *TaskTemplateMutation) SubtasksIDs() (ids []uuid.UUID) {
	for id := range m.subtasks {
		ids = append(ids, id)
	}
	return
}

// ResetSubtasks resets all changes to the "subtasks" edge.
func (m *TaskTemplateMutation) ResetSubtasks() {
	m.subtasks = nil
	m.clearedsubtasks = false
	m.removedsubtasks = nil
}

// Where appends a list predicates to the TaskTemplateMutation builder.
func (m *TaskTemplateMutation) Where(ps ...predicate.TaskTemplate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TaskTemplateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TaskTemplateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TaskTemplate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TaskTemplateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TaskTemplateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TaskTemplate).
func (m *TaskTemplateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskTemplateMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, tasktemplate.FieldName)
	}
	if m.description != nil {
		fields = append(fields, tasktemplate.FieldDescription)
	}
	if m.created_by != nil {
		fields = append(fields, tasktemplate.FieldCreatedBy)
	}
	if m.organization_id != nil {
		fields = append(fields, tasktemplate.FieldOrganizationID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskTemplateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tasktemplate.FieldName:
		return m.Name()
	case tasktemplate.FieldDescription:
		return m.Description()
	case tasktemplate.FieldCreatedBy:
		return m.CreatedBy()
	case tasktemplate.FieldOrganizationID:
		return m.OrganizationID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskTemplateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tasktemplate.FieldName:
		return m.OldName(ctx)
	case tasktemplate.FieldDescription:
		return m.OldDescription(ctx)
	case tasktemplate.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case tasktemplate.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	}
	return nil, fmt.Errorf("unknown TaskTemplate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskTemplateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tasktemplate.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tasktemplate.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case tasktemplate.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case tasktemplate.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	}
	return fmt.Errorf("unknown TaskTemplate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskTemplateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskTemplateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskTemplateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TaskTemplate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskTemplateMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskTemplateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskTemplateMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TaskTemplate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskTemplateMutation) ResetField(name string) error {
	switch name {
	case tasktemplate.FieldName:
		m.ResetName()
		return nil
	case tasktemplate.FieldDescription:
		m.ResetDescription()
		return nil
	case tasktemplate.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case tasktemplate.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	}
	return fmt.Errorf("unknown TaskTemplate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskTemplateMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.ward != nil {
		edges = append(edges, tasktemplate.EdgeWard)
	}
	if m.subtasks != nil {
		edges = append(edges, tasktemplate.EdgeSubtasks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskTemplateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tasktemplate.EdgeWard:
		if id := m.ward; id != nil {
			return []ent.Value{*id}
		}
	case tasktemplate.EdgeSubtasks:
		ids := make([]ent.Value, 0, len(m.subtasks))
		for id := range m.subtasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskTemplateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedsubtasks != nil {
		edges = append(edges, tasktemplate.EdgeSubtasks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskTemplateMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tasktemplate.EdgeSubtasks:
		ids := make([]ent.Value, 0, len(m.removedsubtasks))
		for id := range m.removedsubtasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskTemplateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedward {
		edges = append(edges, tasktemplate.EdgeWard)
	}
	if m.clearedsubtasks {
		edges = append(edges, tasktemplate.EdgeSubtasks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskTemplateMutation) EdgeCleared(name string) bool {
	switch name {
	case tasktemplate.EdgeWard:
		return m.clearedward
	case tasktemplate.EdgeSubtasks:
		return m.clearedsubtasks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskTemplateMutation) ClearEdge(name string) error {
	switch name {
	case tasktemplate.EdgeWard:
		m.ClearWard()
		return nil
	}
	return fmt.Errorf("unknown TaskTemplate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskTemplateMutation) ResetEdge(name string) error {
	switch name {
	case tasktemplate.EdgeWard:
		m.ResetWard()
		return nil
	case tasktemplate.EdgeSubtasks:
		m.ResetSubtasks()
		return nil
	}
	return fmt.Errorf("unknown TaskTemplate edge %s", name)
}

// TaskTemplateSubTaskMutation represents an operation that mutates the TaskTemplateSubTask nodes in the graph.
type TaskTemplateSubTaskMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	name                 *string
	clearedFields        map[string]struct{}
	task_template        *uuid.UUID
	clearedtask_template bool
	done                 bool
	oldValue             func(context.Context) (*TaskTemplateSubTask, error)
	predicates           []predicate.TaskTemplateSubTask
}

var _ ent.Mutation = (*TaskTemplateSubTaskMutation)(nil)

// tasktemplatesubtaskOption allows management of the mutation configuration using functional options.
type tasktemplatesubtaskOption func(*TaskTemplateSubTaskMutation)

// newTaskTemplateSubTaskMutation creates new mutation for the TaskTemplateSubTask entity.
func newTaskTemplateSubTaskMutation(c config, op Op, opts ...tasktemplatesubtaskOption) *TaskTemplateSubTaskMutation {
	m := &TaskTemplateSubTaskMutation{
		config:        c,
		op:            op,
		typ:           TypeTaskTemplateSubTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskTemplateSubTaskID sets the ID field of the mutation.
func withTaskTemplateSubTaskID(id uuid.UUID) tasktemplatesubtaskOption {
	return func(m *TaskTemplateSubTaskMutation) {
		var (
			err   error
			once  sync.Once
			value *TaskTemplateSubTask
		)
		m.oldValue = func(ctx context.Context) (*TaskTemplateSubTask, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TaskTemplateSubTask.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTaskTemplateSubTask sets the old TaskTemplateSubTask of the mutation.
func withTaskTemplateSubTask(node *TaskTemplateSubTask) tasktemplatesubtaskOption {
	return func(m *TaskTemplateSubTaskMutation) {
		m.oldValue = func(context.Context) (*TaskTemplateSubTask, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskTemplateSubTaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskTemplateSubTaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TaskTemplateSubTask entities.
func (m *TaskTemplateSubTaskMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskTemplateSubTaskMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskTemplateSubTaskMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TaskTemplateSubTask.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TaskTemplateSubTaskMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TaskTemplateSubTaskMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TaskTemplateSubTask entity.
// If the TaskTemplateSubTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskTemplateSubTaskMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TaskTemplateSubTaskMutation) ResetName() {
	m.name = nil
}

// SetTaskTemplateID sets the "task_template" edge to the TaskTemplate entity by id.
func (m *TaskTemplateSubTaskMutation) SetTaskTemplateID(id uuid.UUID) {
	m.task_template = &id
}

// ClearTaskTemplate clears the "task_template" edge to the TaskTemplate entity.
func (m *TaskTemplateSubTaskMutation) ClearTaskTemplate() {
	m.clearedtask_template = true
}

// TaskTemplateCleared reports if the "task_template" edge to the TaskTemplate entity was cleared.
func (m *TaskTemplateSubTaskMutation) TaskTemplateCleared() bool {
	return m.clearedtask_template
}

// TaskTemplateID returns the "task_template" edge ID in the mutation.
func (m *TaskTemplateSubTaskMutation) TaskTemplateID() (id uuid.UUID, exists bool) {
	if m.task_template != nil {
		return *m.task_template, true
	}
	return
}

// TaskTemplateIDs returns the "task_template" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaskTemplateID instead. It exists only for internal usage by the builders.
func (m *TaskTemplateSubTaskMutation) TaskTemplateIDs() (ids []uuid.UUID) {
	if id := m.task_template; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTaskTemplate resets all changes to the "task_template" edge.
func (m *TaskTemplateSubTaskMutation) ResetTaskTemplate() {
	m.task_template = nil
	m.clearedtask_template = false
}

// Where appends a list predicates to the TaskTemplateSubTaskMutation builder.
func (m *TaskTemplateSubTaskMutation) Where(ps ...predicate.TaskTemplateSubTask) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TaskTemplateSubTaskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TaskTemplateSubTaskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TaskTemplateSubTask, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TaskTemplateSubTaskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TaskTemplateSubTaskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TaskTemplateSubTask).
func (m *TaskTemplateSubTaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskTemplateSubTaskMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, tasktemplatesubtask.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskTemplateSubTaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tasktemplatesubtask.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskTemplateSubTaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tasktemplatesubtask.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown TaskTemplateSubTask field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskTemplateSubTaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tasktemplatesubtask.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown TaskTemplateSubTask field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskTemplateSubTaskMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskTemplateSubTaskMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskTemplateSubTaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TaskTemplateSubTask numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskTemplateSubTaskMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskTemplateSubTaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskTemplateSubTaskMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TaskTemplateSubTask nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskTemplateSubTaskMutation) ResetField(name string) error {
	switch name {
	case tasktemplatesubtask.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown TaskTemplateSubTask field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskTemplateSubTaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.task_template != nil {
		edges = append(edges, tasktemplatesubtask.EdgeTaskTemplate)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskTemplateSubTaskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tasktemplatesubtask.EdgeTaskTemplate:
		if id := m.task_template; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskTemplateSubTaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskTemplateSubTaskMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskTemplateSubTaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtask_template {
		edges = append(edges, tasktemplatesubtask.EdgeTaskTemplate)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskTemplateSubTaskMutation) EdgeCleared(name string) bool {
	switch name {
	case tasktemplatesubtask.EdgeTaskTemplate:
		return m.clearedtask_template
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskTemplateSubTaskMutation) ClearEdge(name string) error {
	switch name {
	case tasktemplatesubtask.EdgeTaskTemplate:
		m.ClearTaskTemplate()
		return nil
	}
	return fmt.Errorf("unknown TaskTemplateSubTask unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskTemplateSubTaskMutation) ResetEdge(name string) error {
	switch name {
	case tasktemplatesubtask.EdgeTaskTemplate:
		m.ResetTaskTemplate()
		return nil
	}
	return fmt.Errorf("unknown TaskTemplateSubTask edge %s", name)
}

// WardMutation represents an operation that mutates the Ward nodes in the graph.
type WardMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	name                  *string
	organization_id       *uuid.UUID
	clearedFields         map[string]struct{}
	rooms                 map[uuid.UUID]struct{}
	removedrooms          map[uuid.UUID]struct{}
	clearedrooms          bool
	task_templates        map[uuid.UUID]struct{}
	removedtask_templates map[uuid.UUID]struct{}
	clearedtask_templates bool
	done                  bool
	oldValue              func(context.Context) (*Ward, error)
	predicates            []predicate.Ward
}

var _ ent.Mutation = (*WardMutation)(nil)

// wardOption allows management of the mutation configuration using functional options.
type wardOption func(*WardMutation)

// newWardMutation creates new mutation for the Ward entity.
func newWardMutation(c config, op Op, opts ...wardOption) *WardMutation {
	m := &WardMutation{
		config:        c,
		op:            op,
		typ:           TypeWard,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWardID sets the ID field of the mutation.
func withWardID(id uuid.UUID) wardOption {
	return func(m *WardMutation) {
		var (
			err   error
			once  sync.Once
			value *Ward
		)
		m.oldValue = func(ctx context.Context) (*Ward, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Ward.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWard sets the old Ward of the mutation.
func withWard(node *Ward) wardOption {
	return func(m *WardMutation) {
		m.oldValue = func(context.Context) (*Ward, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WardMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WardMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Ward entities.
func (m *WardMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WardMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WardMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Ward.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *WardMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *WardMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Ward entity.
// If the Ward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WardMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *WardMutation) ResetName() {
	m.name = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *WardMutation) SetOrganizationID(u uuid.UUID) {
	m.organization_id = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *WardMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the Ward entity.
// If the Ward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WardMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *WardMutation) ResetOrganizationID() {
	m.organization_id = nil
}

// AddRoomIDs adds the "rooms" edge to the Room entity by ids.
func (m *WardMutation) AddRoomIDs(ids ...uuid.UUID) {
	if m.rooms == nil {
		m.rooms = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.rooms[ids[i]] = struct{}{}
	}
}

// ClearRooms clears the "rooms" edge to the Room entity.
func (m *WardMutation) ClearRooms() {
	m.clearedrooms = true
}

// RoomsCleared reports if the "rooms" edge to the Room entity was cleared.
func (m *WardMutation) RoomsCleared() bool {
	return m.clearedrooms
}

// RemoveRoomIDs removes the "rooms" edge to the Room entity by IDs.
func (m *WardMutation) RemoveRoomIDs(ids ...uuid.UUID) {
	if m.removedrooms == nil {
		m.removedrooms = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.rooms, ids[i])
		m.removedrooms[ids[i]] = struct{}{}
	}
}

// RemovedRooms returns the removed IDs of the "rooms" edge to the Room entity.
func (m *WardMutation) RemovedRoomsIDs() (ids []uuid.UUID) {
	for id := range m.removedrooms {
		ids = append(ids, id)
	}
	return
}

// RoomsIDs returns the "rooms" edge IDs in the mutation.
func (m *WardMutation) RoomsIDs() (ids []uuid.UUID) {
	for id := range m.rooms {
		ids = append(ids, id)
	}
	return
}

// ResetRooms resets all changes to the "rooms" edge.
func (m *WardMutation) ResetRooms() {
	m.rooms = nil
	m.clearedrooms = false
	m.removedrooms = nil
}

// AddTaskTemplateIDs adds the "task_templates" edge to the TaskTemplate entity by ids.
func (m *WardMutation) AddTaskTemplateIDs(ids ...uuid.UUID) {
	if m.task_templates == nil {
		m.task_templates = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.task_templates[ids[i]] = struct{}{}
	}
}

// ClearTaskTemplates clears the "task_templates" edge to the TaskTemplate entity.
func (m *WardMutation) ClearTaskTemplates() {
	m.clearedtask_templates = true
}

// TaskTemplatesCleared reports if the "task_templates" edge to the TaskTemplate entity was cleared.
func (m *WardMutation) TaskTemplatesCleared() bool {
	return m.clearedtask_templates
}

// RemoveTaskTemplateIDs removes the "task_templates" edge to the TaskTemplate entity by IDs.
func (m *WardMutation) RemoveTaskTemplateIDs(ids ...uuid.UUID) {
	if m.removedtask_templates == nil {
		m.removedtask_templates = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.task_templates, ids[i])
		m.removedtask_templates[ids[i]] = struct{}{}
	}
}

// RemovedTaskTemplates returns the removed IDs of the "task_templates" edge to the TaskTemplate entity.
func (m *WardMutation) RemovedTaskTemplatesIDs() (ids []uuid.UUID) {
	for id := range m.removedtask_templates {
		ids = append(ids, id)
	}
	return
}

// TaskTemplatesIDs returns the "task_templates" edge IDs in the mutation.
func (m *WardMutation) TaskTemplatesIDs() (ids []uuid.UUID) {
	for id := range m.task_templates {
		ids = append(ids, id)
	}
	return
}

// ResetTaskTemplates resets all changes to the "task_templates" edge.
func (m *WardMutation) ResetTaskTemplates() {
	m.task_templates = nil
	m.clearedtask_templates = false
	m.removedtask_templates = nil
}

// Where appends a list predicates to the WardMutation builder.
func (m *WardMutation) Where(ps ...predicate.Ward) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WardMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WardMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Ward, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WardMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WardMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Ward).
func (m *WardMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WardMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, ward.FieldName)
	}
	if m.organization_id != nil {
		fields = append(fields, ward.FieldOrganizationID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WardMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ward.FieldName:
		return m.Name()
	case ward.FieldOrganizationID:
		return m.OrganizationID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WardMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ward.FieldName:
		return m.OldName(ctx)
	case ward.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	}
	return nil, fmt.Errorf("unknown Ward field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WardMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ward.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case ward.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	}
	return fmt.Errorf("unknown Ward field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WardMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WardMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WardMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Ward numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WardMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WardMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WardMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Ward nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WardMutation) ResetField(name string) error {
	switch name {
	case ward.FieldName:
		m.ResetName()
		return nil
	case ward.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	}
	return fmt.Errorf("unknown Ward field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WardMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.rooms != nil {
		edges = append(edges, ward.EdgeRooms)
	}
	if m.task_templates != nil {
		edges = append(edges, ward.EdgeTaskTemplates)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WardMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ward.EdgeRooms:
		ids := make([]ent.Value, 0, len(m.rooms))
		for id := range m.rooms {
			ids = append(ids, id)
		}
		return ids
	case ward.EdgeTaskTemplates:
		ids := make([]ent.Value, 0, len(m.task_templates))
		for id := range m.task_templates {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WardMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedrooms != nil {
		edges = append(edges, ward.EdgeRooms)
	}
	if m.removedtask_templates != nil {
		edges = append(edges, ward.EdgeTaskTemplates)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WardMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case ward.EdgeRooms:
		ids := make([]ent.Value, 0, len(m.removedrooms))
		for id := range m.removedrooms {
			ids = append(ids, id)
		}
		return ids
	case ward.EdgeTaskTemplates:
		ids := make([]ent.Value, 0, len(m.removedtask_templates))
		for id := range m.removedtask_templates {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WardMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedrooms {
		edges = append(edges, ward.EdgeRooms)
	}
	if m.clearedtask_templates {
		edges = append(edges, ward.EdgeTaskTemplates)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WardMutation) EdgeCleared(name string) bool {
	switch name {
	case ward.EdgeRooms:
		return m.clearedrooms
	case ward.EdgeTaskTemplates:
		return m.clearedtask_templates
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WardMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Ward unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WardMutation) ResetEdge(name string) error {
	switch name {
	case ward.EdgeRooms:
		m.ResetRooms()
		return nil
	case ward.EdgeTaskTemplates:
		m.ResetTaskTemplates()
		return nil
	}
	return fmt.Errorf("unknown Ward edge %s", name)
}
