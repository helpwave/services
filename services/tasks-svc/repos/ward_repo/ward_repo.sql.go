// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: ward_repo.sql

package ward_repo

import (
	"context"

	"github.com/google/uuid"
)

const createWard = `-- name: CreateWard :one
INSERT INTO wards (name) VALUES ($1) RETURNING id, consistency
`

type CreateWardRow struct {
	ID          uuid.UUID
	Consistency int64
}

func (q *Queries) CreateWard(ctx context.Context, name string) (CreateWardRow, error) {
	row := q.db.QueryRow(ctx, createWard, name)
	var i CreateWardRow
	err := row.Scan(&i.ID, &i.Consistency)
	return i, err
}

const deleteWard = `-- name: DeleteWard :exec
DELETE FROM wards WHERE id = $1
`

func (q *Queries) DeleteWard(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteWard, id)
	return err
}

const existsWard = `-- name: ExistsWard :one
SELECT EXISTS (
	SELECT 1
	FROM wards
	WHERE id = $1
) ward_exists
`

func (q *Queries) ExistsWard(ctx context.Context, id uuid.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, existsWard, id)
	var ward_exists bool
	err := row.Scan(&ward_exists)
	return ward_exists, err
}

const getWardById = `-- name: GetWardById :one
SELECT id, name, consistency FROM wards
WHERE id = $1
`

func (q *Queries) GetWardById(ctx context.Context, wardID uuid.UUID) (Ward, error) {
	row := q.db.QueryRow(ctx, getWardById, wardID)
	var i Ward
	err := row.Scan(&i.ID, &i.Name, &i.Consistency)
	return i, err
}

const getWardByIdWithRoomsBedsAndTaskTemplates = `-- name: GetWardByIdWithRoomsBedsAndTaskTemplates :many
SELECT
	wards.id as ward_id,
	wards.name as ward_name,
	wards.consistency as ward_consistency,
	rooms.id as room_id,
	rooms.name as room_name,
	rooms.consistency as room_consistency,
	beds.id as bed_id,
	beds.name as bed_name,
	beds.consistency as bed_consistency,
	task_templates.id as task_template_id,
	task_templates.name as task_template_name,
	task_templates.consistency as task_template_consistency,
	task_template_subtasks.id as task_template_subtask_id,
	task_template_subtasks.name as task_template_subtask_name
FROM wards
		 LEFT JOIN rooms ON rooms.ward_id = wards.id
		 LEFT JOIN beds ON beds.room_id = rooms.id
		 LEFT JOIN task_templates ON task_templates.ward_id = wards.id
		 LEFT JOIN task_template_subtasks ON task_template_subtasks.task_template_id = task_templates.id
WHERE wards.id = $1
`

type GetWardByIdWithRoomsBedsAndTaskTemplatesRow struct {
	WardID                  uuid.UUID
	WardName                string
	WardConsistency         int64
	RoomID                  uuid.NullUUID
	RoomName                *string
	RoomConsistency         *int64
	BedID                   uuid.NullUUID
	BedName                 *string
	BedConsistency          *int64
	TaskTemplateID          uuid.NullUUID
	TaskTemplateName        *string
	TaskTemplateConsistency *int64
	TaskTemplateSubtaskID   uuid.NullUUID
	TaskTemplateSubtaskName *string
}

func (q *Queries) GetWardByIdWithRoomsBedsAndTaskTemplates(ctx context.Context, wardID uuid.UUID) ([]GetWardByIdWithRoomsBedsAndTaskTemplatesRow, error) {
	rows, err := q.db.Query(ctx, getWardByIdWithRoomsBedsAndTaskTemplates, wardID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetWardByIdWithRoomsBedsAndTaskTemplatesRow{}
	for rows.Next() {
		var i GetWardByIdWithRoomsBedsAndTaskTemplatesRow
		if err := rows.Scan(
			&i.WardID,
			&i.WardName,
			&i.WardConsistency,
			&i.RoomID,
			&i.RoomName,
			&i.RoomConsistency,
			&i.BedID,
			&i.BedName,
			&i.BedConsistency,
			&i.TaskTemplateID,
			&i.TaskTemplateName,
			&i.TaskTemplateConsistency,
			&i.TaskTemplateSubtaskID,
			&i.TaskTemplateSubtaskName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWards = `-- name: GetWards :many
SELECT id, name, consistency FROM wards
`

func (q *Queries) GetWards(ctx context.Context) ([]Ward, error) {
	rows, err := q.db.Query(ctx, getWards)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Ward{}
	for rows.Next() {
		var i Ward
		if err := rows.Scan(&i.ID, &i.Name, &i.Consistency); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWardsWithCounts = `-- name: GetWardsWithCounts :many
SELECT
	wards.id, wards.name, wards.consistency,
	COUNT(DISTINCT beds.id) AS bed_count,
	COUNT(DISTINCT CASE WHEN tasks.status = $1 THEN tasks.id ELSE NULL END) AS todo_count,
	COUNT(DISTINCT CASE WHEN tasks.status = $2 THEN tasks.id ELSE NULL END) AS in_progress_count,
	COUNT(DISTINCT CASE WHEN tasks.status = $3 THEN tasks.id ELSE NULL END) AS done_count
FROM wards
		 LEFT JOIN rooms ON rooms.ward_id = wards.id
		 LEFT JOIN beds ON beds.room_id = rooms.id
		 LEFT JOIN patients ON patients.bed_id = beds.id
		 LEFT JOIN tasks ON tasks.patient_id = patients.id
WHERE (wards.id = ANY($4::uuid[]) OR $4 IS NULL)
GROUP BY wards.id
`

type GetWardsWithCountsParams struct {
	StatusTodo       int32
	StatusInProgress int32
	StatusDone       int32
	WardIds          []uuid.UUID
}

type GetWardsWithCountsRow struct {
	Ward            Ward
	BedCount        int64
	TodoCount       int64
	InProgressCount int64
	DoneCount       int64
}

func (q *Queries) GetWardsWithCounts(ctx context.Context, arg GetWardsWithCountsParams) ([]GetWardsWithCountsRow, error) {
	rows, err := q.db.Query(ctx, getWardsWithCounts,
		arg.StatusTodo,
		arg.StatusInProgress,
		arg.StatusDone,
		arg.WardIds,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetWardsWithCountsRow{}
	for rows.Next() {
		var i GetWardsWithCountsRow
		if err := rows.Scan(
			&i.Ward.ID,
			&i.Ward.Name,
			&i.Ward.Consistency,
			&i.BedCount,
			&i.TodoCount,
			&i.InProgressCount,
			&i.DoneCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateWard = `-- name: UpdateWard :one
UPDATE wards
SET	name = coalesce($1, name),
	consistency = consistency + 1
WHERE id = $2
RETURNING consistency
`

type UpdateWardParams struct {
	Name *string
	ID   uuid.UUID
}

func (q *Queries) UpdateWard(ctx context.Context, arg UpdateWardParams) (int64, error) {
	row := q.db.QueryRow(ctx, updateWard, arg.Name, arg.ID)
	var consistency int64
	err := row.Scan(&consistency)
	return consistency, err
}
